"""
Fibonacci CLI in Python with Iterative, Recursive, and DP variants.
Outputs timing and operation counts in a CSV-friendly format matching the sample midterm tools.

Author: Autogenerated
"""
from enum import Enum
from functools import lru_cache
import argparse
from typing import Callable, List, Tuple
import time


# Global operation counter for fair comparisons across algorithms
OPS = 0


class FibType(Enum):
    ITERATIVE_DP_TOGETHER = 4
    ALL = 3
    DP = 2
    RECURSIVE = 1
    ITERATIVE = 0


def _reset_ops() -> None:
    global OPS
    OPS = 0


def fib_recursive_single(n: int) -> int:
    """
    Naive recursive Fibonacci with OPS increment on non-base cases.
    Uses F(1) = 1, F(2) = 1.
    """
    if n <= 2:
        return 1
    global OPS
    OPS += 1
    return fib_recursive_single(n - 1) + fib_recursive_single(n - 2)


@lru_cache(maxsize=None)
def fib_dp_single(n: int) -> int:
    """
    Top-down DP (memoized) Fibonacci with OPS increment on non-base cases.
    Uses F(1) = 1, F(2) = 1.
    """
    if n <= 2:
        return 1
    global OPS
    OPS += 1
    return fib_dp_single(n - 1) + fib_dp_single(n - 2)


def fib_iterative_series(n: int) -> List[int]:
    """
    Iterative Fibonacci producing series 1..n with OPS increment per step.
    Uses F(1) = 1, F(2) = 1.
    """
    if n <= 0:
        return []
    if n == 1:
        return [1]
    global OPS
    series: List[int] = [1, 1]
    # We already have two values; build up to n
    for _ in range(3, n + 1):
        OPS += 1
        series.append(series[-1] + series[-2])
    return series


def fib_recursive_series(n: int) -> List[int]:
    """Generate series 1..n using naive recursion."""
    # Warm cache is irrelevant here; naive recursion only
    return [fib_recursive_single(i) for i in range(1, n + 1)]


def fib_dp_series(n: int) -> List[int]:
    """Generate series 1..n using memoized recursion."""
    return [fib_dp_single(i) for i in range(1, n + 1)]


def run_and_time(func: Callable[[int], List[int]], n: int, print_it: bool = False) -> Tuple[float, int]:
    """
    Measure execution time and operations for a series-producing function.
    Returns (time_seconds, OPS).
    """
    _reset_ops()
    start = time.perf_counter()
    result = func(n)
    end = time.perf_counter()
    if print_it:
        print(" ".join(str(x) for x in result))
    return end - start, OPS


def main() -> None:
    parser = argparse.ArgumentParser(description="Fibonacci Analysis")
    parser.add_argument("n", type=int, help="Generate Fibonacci series 1..n and/or time it")
    parser.add_argument(
        "algo",
        type=int,
        choices=[0, 1, 2, 3, 4],
        default=FibType.ITERATIVE.value,
        help="0=iterative, 1=recursive, 2=dp, 3=all, 4=iterative and dp together",
    )
    parser.add_argument("--print", action="store_true", default=False, help="Print the series")
    args = parser.parse_args()

    algo = FibType(args.algo)

    if algo == FibType.RECURSIVE:
        print("Recursive Version")
        t, ops = run_and_time(fib_recursive_series, args.n, args.print)
        print(f"Time: {t}({ops})")
    elif algo == FibType.DP:
        print("Dynamic Programming Version")
        # Clear DP cache between runs
        fib_dp_single.cache_clear()
        t, ops = run_and_time(fib_dp_series, args.n, args.print)
        print(f"Time: {t}({ops})")
    elif algo == FibType.ITERATIVE_DP_TOGETHER:
        fib_dp_single.cache_clear()
        t1, ops1 = run_and_time(fib_iterative_series, args.n)
        t2, ops2 = run_and_time(fib_dp_series, args.n)
        print(f"{t1:0.6f},{ops1},{t2:0.6f},{ops2},-,-")
    elif algo == FibType.ALL:
        fib_dp_single.cache_clear()
        t1, ops1 = run_and_time(fib_iterative_series, args.n)
        t2, ops2 = run_and_time(fib_dp_series, args.n)
        t3, ops3 = run_and_time(fib_recursive_series, args.n)
        print(f"{t1:0.6f},{ops1},{t2:0.6f},{ops2},{t3:0.6f},{ops3}")
    else:
        print("Iterative Version")
        t, ops = run_and_time(fib_iterative_series, args.n, args.print)
        print(f"Time: {t}({ops})")


if __name__ == "__main__":
    main()


